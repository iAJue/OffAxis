<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>GLB 最小示例（切换模型）</title>
    <style>
      html,
      body {
        height: 100%;
        margin: 0;
        overflow: hidden;
        background: #0b1220;
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto,
          Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      }
      #c {
        width: 100%;
        height: 100%;
        display: block;
      }
      #ui {
        position: fixed;
        top: 12px;
        left: 12px;
        display: flex;
        gap: 8px;
        align-items: center;
        padding: 10px 12px;
        border: 1px solid rgba(255, 255, 255, 0.12);
        background: rgba(10, 18, 34, 0.72);
        color: rgba(255, 255, 255, 0.9);
        border-radius: 10px;
        backdrop-filter: blur(10px);
      }
      #ui select,
      #ui button {
        background: rgba(255, 255, 255, 0.08);
        color: rgba(255, 255, 255, 0.92);
        border: 1px solid rgba(255, 255, 255, 0.14);
        border-radius: 8px;
        padding: 6px 10px;
        outline: none;
      }
      #ui .toggle {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        user-select: none;
        cursor: pointer;
        padding: 4px 8px;
        border-radius: 8px;
        border: 1px solid rgba(255, 255, 255, 0.14);
        background: rgba(255, 255, 255, 0.06);
      }
      #ui input[type="checkbox"] {
        width: 14px;
        height: 14px;
        accent-color: #f472b6;
      }
      #ui input[type="range"] {
        width: 120px;
      }
      #ui .small {
        font-size: 12px;
        color: rgba(255, 255, 255, 0.72);
      }
      #status {
        font-size: 12px;
        color: rgba(255, 255, 255, 0.72);
        min-width: 160px;
      }
      #webcamPane {
        position: fixed;
        right: 12px;
        bottom: 12px;
        width: 180px;
        border-radius: 12px;
        overflow: hidden;
        border: 1px solid rgba(255, 255, 255, 0.12);
        background: rgba(10, 18, 34, 0.72);
        display: none;
      }
      #webcamPane video {
        width: 100%;
        height: auto;
        display: block;
        transform: scaleX(-1);
      }
    </style>

    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
      }
    </script>
  </head>
  <body>
    <div id="ui">
      <label for="modelSelect">模型</label>
      <select id="modelSelect"></select>
      <label class="toggle" title="卡通分层光照 + 描边 + 粒子">
        <input id="animeToggle" type="checkbox" checked />
        场景
      </label>
      <label class="toggle" title="离轴投影（off-axis）+ 头动追踪（单人）">
        <input id="offAxisToggle" type="checkbox" />
        裸眼3D
      </label>
      <label class="small" title="头动幅度（鼠标也可模拟）">
        强度
        <input id="parallaxGain" type="range" min="0" max="2" step="0.01" value="1" />
      </label>
      <button id="trackBtn" type="button">开启追踪</button>
      <button id="reloadBtn" type="button">重载</button>
      <div id="status"></div>
    </div>
    <canvas id="c"></canvas>
    <div id="webcamPane" aria-hidden="true">
      <video id="webcam" autoplay playsinline muted></video>
    </div>

    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";
      import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
      import { DRACOLoader } from "three/addons/loaders/DRACOLoader.js";

      const MODELS = [
        { name: "model.glb", url: "./model.glb" },
        { name: "model2.glb", url: "./model2.glb" },
        { name: "model3.glb", url: "./model3.glb" }
      ];

      const canvas = document.getElementById("c");
      const statusEl = document.getElementById("status");
      const selectEl = document.getElementById("modelSelect");
      const reloadBtn = document.getElementById("reloadBtn");
      const animeToggleEl = document.getElementById("animeToggle");
      const offAxisToggleEl = document.getElementById("offAxisToggle");
      const parallaxGainEl = document.getElementById("parallaxGain");
      const trackBtn = document.getElementById("trackBtn");
      const webcamPane = document.getElementById("webcamPane");
      const webcamVideo = document.getElementById("webcam");

      const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;

      const scene = new THREE.Scene();
      scene.background = null;

      const camera = new THREE.PerspectiveCamera(50, 1, 0.01, 10_000);
      camera.position.set(2, 1.2, 2.2);

      const controls = new OrbitControls(camera, canvas);
      controls.enableDamping = true;
      controls.dampingFactor = 0.08;

      scene.add(new THREE.HemisphereLight(0xffffff, 0x223344, 1.05));
      const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
      dirLight.position.set(3, 6, 4);
      dirLight.castShadow = true;
      dirLight.shadow.mapSize.set(2048, 2048);
      dirLight.shadow.bias = -0.00008;
      scene.add(dirLight);
      scene.add(dirLight.target);
      const rimLight = new THREE.DirectionalLight(0xffe4f1, 0.55);
      rimLight.position.set(-4, 2, -3);
      scene.add(rimLight);

      const loader = new GLTFLoader();
      const dracoLoader = new DRACOLoader();
      dracoLoader.setDecoderPath("https://www.gstatic.com/draco/v1/decoders/");
      loader.setDRACOLoader(dracoLoader);

      let currentRoot = null;
      const offAxis = {
        enabled: false,
        tracking: false,
        screenOrigin: new THREE.Vector3(0, 0, 0),
        screenHeight: 1,
        baseDistance: 2,
        head: new THREE.Vector3(0, 0, 2),
        headTarget: new THREE.Vector3(0, 0, 2),
        refEyeDist: null,
        stream: null,
        faceLandmarker: null,
        lastVideoTime: -1
      };
      const normalCameraState = {
        position: new THREE.Vector3(),
        quaternion: new THREE.Quaternion(),
        target: new THREE.Vector3()
      };
      const offAxisTmp = {
        pa: new THREE.Vector3(),
        pb: new THREE.Vector3(),
        pc: new THREE.Vector3(),
        vr: new THREE.Vector3(),
        vu: new THREE.Vector3(),
        vn: new THREE.Vector3(),
        va: new THREE.Vector3(),
        vb: new THREE.Vector3(),
        vc: new THREE.Vector3(),
        eye: new THREE.Vector3(),
        basis: new THREE.Matrix4()
      };
      const toonGradientMap = createToonGradientMap(5);
      const sky = createGradientSky();
      scene.add(sky);
      const ground = createGround(toonGradientMap);
      scene.add(ground);
      const sparkles = createSparkles();
      scene.add(sparkles);

      function setStatus(text) {
        statusEl.textContent = text ?? "";
      }

      function disposeObject3D(root) {
        if (!root) return;
        const disposedGeometries = new Set();
        const disposedMaterials = new Set();
        const disposedTextures = new Set();

        root.traverse((obj) => {
          if (obj.userData?._origMaterial) collectMaterial(obj.userData._origMaterial);
          if (obj.userData?._toonMaterial) collectMaterial(obj.userData._toonMaterial);

          if (obj.geometry && !disposedGeometries.has(obj.geometry)) {
            disposedGeometries.add(obj.geometry);
            obj.geometry.dispose();
          }
          collectMaterial(obj.material);
        });

        function collectMaterial(material) {
          if (!material) return;
          if (Array.isArray(material)) {
            for (const m of material) collectMaterial(m);
            return;
          }
          if (disposedMaterials.has(material)) return;
          disposedMaterials.add(material);

          for (const key of Object.keys(material)) {
            const value = material[key];
            if (value && typeof value === "object" && value.isTexture && !disposedTextures.has(value)) {
              disposedTextures.add(value);
              value.dispose();
            }
          }
          material.dispose();
        }
      }

      function applyAnimeStyle(root, enabled) {
        root.traverse((obj) => {
          if (!obj.isMesh) return;
          if (obj.userData?._isOutline) return;

          obj.castShadow = true;
          obj.receiveShadow = true;

          if (!obj.userData._origMaterial) {
            obj.userData._origMaterial = obj.material;
          }

          if (enabled) {
            if (!obj.userData._toonMaterial) {
              obj.userData._toonMaterial = toToonMaterial(obj.userData._origMaterial);
            }
            obj.material = obj.userData._toonMaterial;
            if (obj.material?.isMeshToonMaterial) {
              if (obj.isSkinnedMesh) obj.material.skinning = true;
              if (obj.morphTargetInfluences) {
                obj.material.morphTargets = true;
                obj.material.morphNormals = true;
              }
              obj.material.needsUpdate = true;
            }
            ensureOutline(obj, true);
          } else {
            obj.material = obj.userData._origMaterial;
            ensureOutline(obj, false);
          }
        });
      }

      function toToonMaterial(original) {
        const pick = Array.isArray(original) ? original[0] : original;
        const toon = new THREE.MeshToonMaterial({
          color: pick?.color?.clone?.() ?? new THREE.Color(0xffffff),
          map: pick?.map ?? null,
          transparent: Boolean(pick?.transparent),
          opacity: pick?.opacity ?? 1,
          side: pick?.side ?? THREE.FrontSide,
          alphaTest: pick?.alphaTest ?? 0,
          gradientMap: toonGradientMap
        });
        if (pick?.emissive) toon.emissive.copy(pick.emissive);
        if (pick?.emissiveMap) toon.emissiveMap = pick.emissiveMap;
        return toon;
      }

      function ensureOutline(mesh, enabled) {
        if (mesh.isSkinnedMesh) return;
        if (enabled) {
          if (mesh.userData._outlineMesh) return;
          const outlineMat = new THREE.MeshBasicMaterial({
            color: 0x111827,
            side: THREE.BackSide,
            transparent: true,
            opacity: 0.95,
            depthWrite: false,
            polygonOffset: true,
            polygonOffsetFactor: 1,
            polygonOffsetUnits: 1
          });
          const outline = new THREE.Mesh(mesh.geometry, outlineMat);
          outline.frustumCulled = false;
          outline.scale.setScalar(1.03);
          outline.userData._isOutline = true;
          mesh.add(outline);
          mesh.userData._outlineMesh = outline;
          return;
        }

        const outline = mesh.userData._outlineMesh;
        if (!outline) return;
        mesh.remove(outline);
        outline.material.dispose();
        mesh.userData._outlineMesh = null;
      }

      function fitCameraToObject(object3d) {
        const box = new THREE.Box3().setFromObject(object3d);
        if (!Number.isFinite(box.min.x) || box.isEmpty()) return;

        const size = box.getSize(new THREE.Vector3());
        const center = box.getCenter(new THREE.Vector3());
        const maxDim = Math.max(size.x, size.y, size.z);

        controls.target.copy(center);
        controls.update();

        const fov = THREE.MathUtils.degToRad(camera.fov);
        const distance = (maxDim / (2 * Math.tan(fov / 2))) * 1.25;

        camera.position.copy(center).add(new THREE.Vector3(distance, distance * 0.35, distance));
        camera.near = Math.max(distance / 200, 0.01);
        camera.far = Math.max(distance * 50, 100);
        camera.updateProjectionMatrix();

        controls.update();
      }

      function setupForModel(root) {
        if (!root) return;
        const box = new THREE.Box3().setFromObject(root);
        if (!Number.isFinite(box.min.x) || box.isEmpty()) return;

        const size = box.getSize(new THREE.Vector3());
        const center = box.getCenter(new THREE.Vector3());
        const maxDim = Math.max(size.x, size.y, size.z);

        applyAnimeStyle(root, animeToggleEl.checked);
        updateEnvironmentStyle();

        const groundY = box.min.y - maxDim * 0.02;
        ground.position.set(center.x, groundY, center.z);
        ground.scale.setScalar(Math.max(maxDim * 1.35, 1));

        sparkles.userData.radius = maxDim;
        sparkles.position.copy(center);
        resetSparkles(sparkles);
        dirLight.target.position.copy(center);
        dirLight.target.updateMatrixWorld();

        const shadowSpan = maxDim * 2.5;
        dirLight.shadow.camera.left = -shadowSpan;
        dirLight.shadow.camera.right = shadowSpan;
        dirLight.shadow.camera.top = shadowSpan;
        dirLight.shadow.camera.bottom = -shadowSpan;
        dirLight.shadow.camera.near = 0.1;
        dirLight.shadow.camera.far = Math.max(maxDim * 10, 50);
        dirLight.shadow.camera.updateProjectionMatrix();

        updateOffAxisDefaults(center, maxDim);
      }

      function updateEnvironmentStyle() {
        const enabled = animeToggleEl.checked;
        sky.material.uniforms.topColor.value.set(enabled ? 0x60a5fa : 0x0b1220);
        sky.material.uniforms.bottomColor.value.set(enabled ? 0xfbcfe8 : 0x0b1220);
        ground.visible = true;
        ground.material.color.set(enabled ? 0xf8fafc : 0x111827);
        ground.material.opacity = enabled ? 0.96 : 0.45;
        ground.material.transparent = true;
        ground.material.needsUpdate = true;
        sparkles.visible = enabled;
      }

      async function loadModel(url) {
        setStatus("加载中…");
        return new Promise((resolve, reject) => {
          loader.load(
            url,
            (gltf) => {
              if (currentRoot) {
                scene.remove(currentRoot);
                disposeObject3D(currentRoot);
              }
              currentRoot = gltf.scene;
              scene.add(currentRoot);
              fitCameraToObject(currentRoot);
              setupForModel(currentRoot);
              setStatus("");
              resolve();
            },
            (evt) => {
              if (!evt.total) return;
              const pct = Math.round((evt.loaded / evt.total) * 100);
              setStatus(`加载中… ${pct}%`);
            },
            (err) => {
              console.error(err);
              setStatus("加载失败，打开控制台看错误");
              reject(err);
            }
          );
        });
      }

      function resize() {
        const width = canvas.clientWidth;
        const height = canvas.clientHeight;
        if (width === 0 || height === 0) return;
        renderer.setSize(width, height, false);
        if (!offAxis.enabled) {
          camera.aspect = width / height;
          camera.updateProjectionMatrix();
        }
      }

      function animate() {
        resize();
        if (!offAxis.enabled) controls.update();
        updateHeadTracking();
        if (offAxis.enabled) updateOffAxisCamera();
        const t = performance.now() * 0.001;
        updateSparkles(sparkles, t);
        sky.position.copy(camera.position);
        renderer.render(scene, camera);
        requestAnimationFrame(animate);
      }

      for (const m of MODELS) {
        const opt = document.createElement("option");
        opt.value = m.url;
        opt.textContent = m.name;
        selectEl.appendChild(opt);
      }

      selectEl.addEventListener("change", () => {
        loadModel(selectEl.value);
      });

      reloadBtn.addEventListener("click", () => {
        loadModel(selectEl.value);
      });

      animeToggleEl.addEventListener("change", () => {
        if (currentRoot) applyAnimeStyle(currentRoot, animeToggleEl.checked);
        updateEnvironmentStyle();
      });

      offAxisToggleEl.addEventListener("change", () => {
        setOffAxisEnabled(offAxisToggleEl.checked);
      });

      trackBtn.addEventListener("click", async () => {
        if (offAxis.tracking) stopTracking();
        else await startTracking();
      });

      window.addEventListener(
        "pointermove",
        (e) => {
          if (!offAxis.enabled) return;
          if (offAxis.tracking) return;
          const width = canvas.clientWidth;
          const height = canvas.clientHeight;
          if (width === 0 || height === 0) return;
          const aspect = width / height;
          const screenWidth = offAxis.screenHeight * aspect;
          const gain = Number(parallaxGainEl.value);
          const x = (e.clientX / width - 0.5) * screenWidth * gain;
          const y = -(e.clientY / height - 0.5) * offAxis.screenHeight * gain;
          offAxis.headTarget.set(x, y, offAxis.baseDistance);
        },
        { passive: true }
      );

      await loadModel(selectEl.value || MODELS[0]?.url);
      animate();

      function setOffAxisEnabled(enabled) {
        offAxis.enabled = enabled;
        controls.enabled = !enabled;

        if (enabled) {
          normalCameraState.position.copy(camera.position);
          normalCameraState.quaternion.copy(camera.quaternion);
          normalCameraState.target.copy(controls.target);
          camera.matrixAutoUpdate = false;
          if (!offAxis.tracking) setStatus("提示：移动鼠标可模拟头动");
          if (currentRoot) setupForModel(currentRoot);
          return;
        }

        camera.matrixAutoUpdate = true;
        camera.position.copy(normalCameraState.position);
        camera.quaternion.copy(normalCameraState.quaternion);
        controls.target.copy(normalCameraState.target);
        controls.update();
        if (currentRoot) fitCameraToObject(currentRoot);
        setStatus("");
      }

      function updateOffAxisDefaults(center, maxDim) {
        offAxis.screenOrigin.copy(center).add(new THREE.Vector3(0, maxDim * 0.05, maxDim * 0.18));
        offAxis.screenHeight = Math.max(maxDim * 0.95, 1);
        offAxis.baseDistance = Math.max(maxDim * 1.35, 1.2);
        if (!offAxis.tracking) offAxis.headTarget.set(0, 0, offAxis.baseDistance);
        if (!offAxis.tracking) offAxis.head.copy(offAxis.headTarget);
        offAxis.refEyeDist = null;
      }

      function updateHeadTracking() {
        if (!offAxis.enabled) return;
        if (!offAxis.tracking) {
          offAxis.head.lerp(offAxis.headTarget, 0.18);
          return;
        }
        if (!offAxis.faceLandmarker) return;
        if (webcamVideo.readyState < 2) return;

        const nowMs = performance.now();
        if (webcamVideo.currentTime === offAxis.lastVideoTime) return;
        offAxis.lastVideoTime = webcamVideo.currentTime;

        const result = offAxis.faceLandmarker.detectForVideo(webcamVideo, nowMs);
        const landmarks = result?.faceLandmarks?.[0];
        if (!landmarks) return;

        const leftEye = landmarks[33];
        const rightEye = landmarks[263];
        if (!leftEye || !rightEye) return;

        const centerX = (leftEye.x + rightEye.x) * 0.5;
        const centerY = (leftEye.y + rightEye.y) * 0.5;
        const eyeDist = Math.hypot(leftEye.x - rightEye.x, leftEye.y - rightEye.y);
        if (!Number.isFinite(eyeDist) || eyeDist <= 0) return;
        if (!offAxis.refEyeDist) offAxis.refEyeDist = eyeDist;

        const width = canvas.clientWidth;
        const height = canvas.clientHeight;
        if (width === 0 || height === 0) return;
        const aspect = width / height;
        const screenWidth = offAxis.screenHeight * aspect;
        const gain = Number(parallaxGainEl.value);

        const x = (centerX - 0.5) * screenWidth * gain;
        const y = -(centerY - 0.5) * offAxis.screenHeight * gain;
        const depthRatio = THREE.MathUtils.clamp(offAxis.refEyeDist / eyeDist, 0.7, 1.8);
        const z = offAxis.baseDistance * depthRatio;

        offAxis.headTarget.set(x, y, z);
        offAxis.head.lerp(offAxis.headTarget, 0.22);
      }

      function updateOffAxisCamera() {
        if (!currentRoot) return;
        const width = canvas.clientWidth;
        const height = canvas.clientHeight;
        if (width === 0 || height === 0) return;

        const aspect = width / height;
        const screenWidth = offAxis.screenHeight * aspect;
        const origin = offAxis.screenOrigin;

        offAxisTmp.pa.set(origin.x - screenWidth / 2, origin.y - offAxis.screenHeight / 2, origin.z);
        offAxisTmp.pb.set(origin.x + screenWidth / 2, origin.y - offAxis.screenHeight / 2, origin.z);
        offAxisTmp.pc.set(origin.x - screenWidth / 2, origin.y + offAxis.screenHeight / 2, origin.z);

        offAxisTmp.vr.subVectors(offAxisTmp.pb, offAxisTmp.pa).normalize();
        offAxisTmp.vu.subVectors(offAxisTmp.pc, offAxisTmp.pa).normalize();
        offAxisTmp.vn.crossVectors(offAxisTmp.vr, offAxisTmp.vu).normalize(); // points toward viewer

        offAxisTmp.eye.copy(origin).add(offAxis.head);

        offAxisTmp.va.subVectors(offAxisTmp.pa, offAxisTmp.eye);
        offAxisTmp.vb.subVectors(offAxisTmp.pb, offAxisTmp.eye);
        offAxisTmp.vc.subVectors(offAxisTmp.pc, offAxisTmp.eye);

        const d = Math.max(0.01, -offAxisTmp.va.dot(offAxisTmp.vn));
        const near = camera.near;
        const far = camera.far;
        const l = (offAxisTmp.vr.dot(offAxisTmp.va) * near) / d;
        const r = (offAxisTmp.vr.dot(offAxisTmp.vb) * near) / d;
        const b = (offAxisTmp.vu.dot(offAxisTmp.va) * near) / d;
        const t = (offAxisTmp.vu.dot(offAxisTmp.vc) * near) / d;

        camera.projectionMatrix.makePerspective(l, r, t, b, near, far);
        camera.projectionMatrixInverse.copy(camera.projectionMatrix).invert();

        offAxisTmp.basis.makeBasis(offAxisTmp.vr, offAxisTmp.vu, offAxisTmp.vn);
        offAxisTmp.basis.setPosition(offAxisTmp.eye);
        camera.matrixWorld.copy(offAxisTmp.basis);
        camera.matrixWorldInverse.copy(offAxisTmp.basis).invert();
        camera.position.copy(offAxisTmp.eye);
      }

      async function startTracking() {
        try {
          setStatus("请求摄像头权限…");
          webcamPane.style.display = "block";

          if (!offAxis.faceLandmarker) {
            setStatus("加载追踪模型…");
            const vision = await import(
              "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/vision_bundle.mjs"
            );
            const fileset = await vision.FilesetResolver.forVisionTasks(
              "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/wasm"
            );
            offAxis.faceLandmarker = await vision.FaceLandmarker.createFromOptions(fileset, {
              baseOptions: {
                modelAssetPath:
                  "https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task",
                delegate: "GPU"
              },
              runningMode: "VIDEO",
              numFaces: 1
            });
          }

          offAxis.stream = await navigator.mediaDevices.getUserMedia({
            video: { facingMode: "user" },
            audio: false
          });
          webcamVideo.srcObject = offAxis.stream;
          await webcamVideo.play();

          offAxis.tracking = true;
          offAxis.lastVideoTime = -1;
          offAxis.refEyeDist = null;
          trackBtn.textContent = "停止追踪";
          if (!offAxis.enabled) {
            offAxisToggleEl.checked = true;
            setOffAxisEnabled(true);
          }
          setStatus("追踪中（单人）");
        } catch (err) {
          console.error(err);
          stopTracking();
          setStatus("开启追踪失败（检查权限/摄像头）");
        }
      }

      function stopTracking() {
        offAxis.tracking = false;
        trackBtn.textContent = "开启追踪";
        offAxis.refEyeDist = null;
        offAxis.lastVideoTime = -1;
        webcamPane.style.display = "none";
        if (offAxis.stream) {
          for (const t of offAxis.stream.getTracks()) t.stop();
          offAxis.stream = null;
        }
        webcamVideo.srcObject = null;
        setStatus(offAxis.enabled ? "提示：移动鼠标可模拟头动" : "");
      }

      function createToonGradientMap(steps) {
        const data = new Uint8Array(steps * 4);
        for (let i = 0; i < steps; i++) {
          const v = Math.round((i / (steps - 1)) * 255);
          data[i * 4 + 0] = v;
          data[i * 4 + 1] = v;
          data[i * 4 + 2] = v;
          data[i * 4 + 3] = 255;
        }
        const tex = new THREE.DataTexture(data, steps, 1, THREE.RGBAFormat);
        tex.needsUpdate = true;
        tex.minFilter = THREE.NearestFilter;
        tex.magFilter = THREE.NearestFilter;
        tex.generateMipmaps = false;
        return tex;
      }

      function createGradientSky() {
        const geo = new THREE.SphereGeometry(1, 32, 16);
        const mat = new THREE.ShaderMaterial({
          side: THREE.BackSide,
          depthWrite: false,
          uniforms: {
            topColor: { value: new THREE.Color(0x60a5fa) },
            bottomColor: { value: new THREE.Color(0xfbcfe8) }
          },
          vertexShader: `
            varying vec3 vWorldPosition;
            void main() {
              vWorldPosition = position;
              gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
          `,
          fragmentShader: `
            uniform vec3 topColor;
            uniform vec3 bottomColor;
            varying vec3 vWorldPosition;
            void main() {
              float h = normalize(vWorldPosition).y;
              float t = smoothstep(-0.15, 0.9, h);
              vec3 col = mix(bottomColor, topColor, t);
              gl_FragColor = vec4(col, 1.0);
            }
          `
        });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.scale.setScalar(5000);
        mesh.frustumCulled = false;
        return mesh;
      }

      function createGround(gradientMap) {
        const tex = createGroundTexture();
        const mat = new THREE.MeshToonMaterial({
          color: 0xf8fafc,
          map: tex,
          gradientMap,
          transparent: true,
          opacity: 0.96
        });
        const mesh = new THREE.Mesh(new THREE.CircleGeometry(1, 96), mat);
        mesh.rotation.x = -Math.PI / 2;
        mesh.receiveShadow = true;
        return mesh;
      }

      function createGroundTexture() {
        const canvas = document.createElement("canvas");
        canvas.width = 512;
        canvas.height = 512;
        const ctx = canvas.getContext("2d");

        const grd = ctx.createRadialGradient(256, 256, 10, 256, 256, 256);
        grd.addColorStop(0, "rgba(255,255,255,0.95)");
        grd.addColorStop(1, "rgba(255,255,255,0.35)");
        ctx.fillStyle = grd;
        ctx.fillRect(0, 0, 512, 512);

        ctx.strokeStyle = "rgba(15, 23, 42, 0.08)";
        ctx.lineWidth = 2;
        for (let r = 40; r <= 240; r += 40) {
          ctx.beginPath();
          ctx.arc(256, 256, r, 0, Math.PI * 2);
          ctx.stroke();
        }

        const tex = new THREE.CanvasTexture(canvas);
        tex.colorSpace = THREE.SRGBColorSpace;
        tex.wrapS = THREE.ClampToEdgeWrapping;
        tex.wrapT = THREE.ClampToEdgeWrapping;
        tex.anisotropy = 2;
        return tex;
      }

      function createSparkles() {
        const count = 220;
        const positions = new Float32Array(count * 3);
        const basePositions = new Float32Array(count * 3);
        const meta = new Float32Array(count * 2);
        for (let i = 0; i < count; i++) {
          meta[i * 2 + 0] = Math.random() * Math.PI * 2;
          meta[i * 2 + 1] = 0.6 + Math.random() * 1.2;
        }

        const geo = new THREE.BufferGeometry();
        geo.setAttribute("position", new THREE.BufferAttribute(positions, 3));

        const mat = new THREE.PointsMaterial({
          size: 0.03,
          map: createSparkleTexture(),
          transparent: true,
          opacity: 0.85,
          depthWrite: false,
          blending: THREE.AdditiveBlending
        });
        const points = new THREE.Points(geo, mat);
        points.frustumCulled = false;
        points.userData.radius = 1;
        points.userData.basePositions = basePositions;
        points.userData.meta = meta;
        return points;
      }

      function resetSparkles(points) {
        const radius = Math.max(points.userData.radius, 1);
        const positions = points.geometry.attributes.position.array;
        const basePositions = points.userData.basePositions;
        const meta = points.userData.meta;
        const count = positions.length / 3;

        for (let i = 0; i < count; i++) {
          const r = radius * (0.15 + Math.random() * 0.95);
          const a = Math.random() * Math.PI * 2;
          const y = (Math.random() * 0.9 + 0.05) * radius * 0.55;
          const x = Math.cos(a) * r;
          const z = Math.sin(a) * r;
          const yy = y;

          basePositions[i * 3 + 0] = x;
          basePositions[i * 3 + 1] = yy;
          basePositions[i * 3 + 2] = z;

          positions[i * 3 + 0] = x;
          positions[i * 3 + 1] = yy;
          positions[i * 3 + 2] = z;

          meta[i * 2 + 0] = Math.random() * Math.PI * 2;
          meta[i * 2 + 1] = 0.6 + Math.random() * 1.2;
        }
        points.geometry.attributes.position.needsUpdate = true;
      }

      function updateSparkles(points, timeSec) {
        if (!points.visible) return;
        const radius = Math.max(points.userData.radius, 1);
        const positions = points.geometry.attributes.position.array;
        const basePositions = points.userData.basePositions;
        const meta = points.userData.meta;
        const count = positions.length / 3;

        for (let i = 0; i < count; i++) {
          const phase = meta[i * 2 + 0];
          const speed = meta[i * 2 + 1];
          positions[i * 3 + 0] = basePositions[i * 3 + 0];
          positions[i * 3 + 1] =
            basePositions[i * 3 + 1] + Math.sin(timeSec * speed + phase) * radius * 0.02;
          positions[i * 3 + 2] = basePositions[i * 3 + 2];
        }
        points.rotation.y += 0.0012;
        points.geometry.attributes.position.needsUpdate = true;
      }

      function createSparkleTexture() {
        const canvas = document.createElement("canvas");
        canvas.width = 128;
        canvas.height = 128;
        const ctx = canvas.getContext("2d");
        ctx.clearRect(0, 0, 128, 128);

        ctx.translate(64, 64);
        ctx.fillStyle = "rgba(255,255,255,1)";
        ctx.beginPath();
        for (let i = 0; i < 8; i++) {
          const ang = (i / 8) * Math.PI * 2;
          const r = i % 2 === 0 ? 46 : 14;
          const x = Math.cos(ang) * r;
          const y = Math.sin(ang) * r;
          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        ctx.closePath();
        ctx.fill();

        const tex = new THREE.CanvasTexture(canvas);
        tex.colorSpace = THREE.SRGBColorSpace;
        tex.minFilter = THREE.LinearMipmapLinearFilter;
        tex.magFilter = THREE.LinearFilter;
        tex.generateMipmaps = true;
        return tex;
      }
    </script>
  </body>
</html>
